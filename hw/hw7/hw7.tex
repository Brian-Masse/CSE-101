\documentclass[12pt, letterpaper]{article}

\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage[left=0.6in, right=0.6in, top=1in, bottom=1in]{geometry}

% for code snippets
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}

% for math and pseudocode
\usepackage{amsmath, amssymb} 
\usepackage{algorithm} 
\usepackage{algpseudocode} 

\definecolor{dkgreen}{rgb}{0.5,0.65,0.5}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{code_blue}{rgb}{0.10,0.27,0.92}
\definecolor{str_red}{rgb}{0.87,0.2,0.14}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{code_blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{str_red},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{CSE 101 Homework 7}
\author{Brian Masse, Taira Sakamoto, Emily Xie, Annabelle Coles}
\date{December 4, 2025}

\begin{document}

\maketitle
\newpage

\begin{enumerate}

% MARK: Question 1
\newpage
\item \textbf{Bus routes}

I am going by bus across town, along a path that includes bus stops $1...m$.  There are $n$ different bus routes $BR_1$ ...$BR_n$, where $BR_i$ goes along my route between stop $s_i$ to stop $f_i$, and costs $c_i$ to ride. I want to go from stop 1 to stop $m$ paying the smallest total amount as I can. You can assume there will always be a later bus for each route passing each stop.

$BTBusCosts(BR_1..BR_n;current; m)$
\begin{enumerate}
\item IF $current \ge m$ return $0$.  
\item $Best=$ infinity;
\item FOR $I=1$ to $n$ do:
\item ~~~IF $s_i \le current < f_i$ 
\item ~~~~~THEN $Best= min(Best, c_i+ BTBusCosts(BR_1...BR_n; f_i; m)$.
\item Return $Best$
\end{enumerate}


\emph{Questions}

\begin{enumerate} 

% MARK: Q1.a
\item Give the tree of recursive calls on the instance $current=1,m=7$, $BR_1= (1,4,3), BR_2=(1,6,7), BR_3=(2,7,8), BR_4 = (5,7,2)$.

\includegraphics[width=0.65\textwidth]{src/Q1A.png}

% MARK: Q1.b
\-\
\item Give an upper bound for the total number of recursive calls for this algorithm.

Note that the worst case has bus routes of the following form, since it maximizes the number of recursive calls at each level. 
\begin{eqnarray*}
    BR_1 &=& (1, 2) \\
    BR_2 &=& (1, 3) \\ 
    &\vdots& \\ 
    BR_n &=& (1, n + 1)
\end{eqnarray*}

Let $x$ be the distance from current position to position m. Then $T(x)$ is the number of recursive calls at a distance x to the finish:

\begin{eqnarray*}
    T(x) &=& T(x - 1) + T(x - 2) + ... T(1) \\
    &\le& x \cdot T(x - 1) \textnormal{ Since, $T(x - i - 1) \le T(x - i) \forall i \ge 1$}
\end{eqnarray*}

Solving the recurrence relation with base case $T(1) = 1$

\begin{eqnarray*}
    T(x) &\le& x \cdot T(x - 1) \\
    &\vdots& \\
    &\le& (x)(x-1) \cdots T(1) \\
    &\le& x!
\end{eqnarray*}

Supplemental Diagram:

\includegraphics[width=0.65\textwidth]{src/Q1B.png}

% MARK: Q1.c
\-\
\item Which variables change during this recursion?

Only the value of $current$ changes each iteration.

% MARK: Q1.d
\-\
\item Define sub-problems: Use the above to define a set of sub-problems that can be used to convert the BT algorithm to a DP algorithm, and define an array or matrix to hold the answers to these subproblems.

\begin{itemize}
    \item Each subproblem starts at some $i \in 1,...m$ and returns the lowest cost path from $i$ to $m$. Each operates with the same bus stops and works towards the same final point $m$. The total number of distinct subproblems is $m$. 
    \item The solutions to subproblems can be stored in a length $m$ array, where each position is the cost to get from position $i$ to $m$
\end{itemize}

% MARK: Q1.e
\-\
\item What are the base cases?

The singular base case is $i = m$, the subproblem where you start at the end. The cost is 0.

% MARK: Q1.f
\-\
\item Translate the BT algorithm into a definition of array/matrix values from other values

On iteration k, $k \in \{1,...m\}$:

~~~~ for $BR_i$ such that $s_i \le k < f_i$:

~~~~~~~~ $costs[k] = min(costs[k], c_i + costs[f_i])$

% MARK: Q1.g
\-\
\item In what order should we fill this array or matrix?

This matrix will be filled from the last position $k = m$ to the first position $k = 1$

% MARK: Q1.h
\-\
\item Assemble these pieces into a DP algorithm.

\begin{lstlisting}
def bus_stops(BR1...BRn, curr, m):

    // there may not be a valid path from every point i to m,
    // so fill all spots except the ending 
    cost = [ infinity ]
    cost[m] = 0

    // go from the end of the route to the start
    for k from m - 1 to 1:

        // si, fi, ci represent the start, finish, and cost of a bus route
        // they are defined and accessible from outside the function
        for all BRi in BR1...BRn such that si <= k < fi:
            cost[k] = min(cost[k], ci + cost[fi])
    
    return cost[1]
\end{lstlisting}

% MARK: Q1.i
\-\
\item Give a time analysis for your DP algorithm.
\begin{itemize}
\item Assuming accessing costs array is $O(1)$ then the main loop $\in O(m) \cdot O(1) \in O(m)$
\item Assume finding all relevant $BR_i$ can be done in worst case $\in O(n)$
\end{itemize}

Therefore, the total runtime of the algorithm is $\in O(n \cdot m)$

% MARK: Q1.j
\-\
\item Give the array or matrix for your DP algorithm on the given example.

\includegraphics[width=0.8\textwidth]{src/Q1J.png}

\end{enumerate}

% MARK: Question 2
\newpage
\item \textbf{Bounded difference sequence}

We say a sequence of numbers $a_1,..a_n$ is $K$-bounded difference if $|a_{i+1}-a_i| \le K$ for all $1 \le i \le n-1$. The maximum bounded difference subsequence problem is,  given sequence $a_1,..a_n$ , and a real number $K > 0$, decide the length $\ell$ of the longest subsequences $a_{i_1},..a_{i_{\ell}}$, $1 = i_1 < i_2 <...i_{\ell}$
including position one, which is $K$-bounded difference.

For example, if $a[1..5]= 2,7,1, 4,3$ and $K=2$, $2, 1, 3$ is a maximum length
$K$ bounded subsequence, as is $2, 4, 3$.

\begin{enumerate}

    \item \textbf{Description of sub-problems}
    
    Let $L[i]$ be the length of the longest $K$-bounded difference subsequence that ends at index $i$ and specifically includes position 1 (i.e., the subsequence must start at $a_1$).

    \item \textbf{Base Case(s)}
    
    $$L[1] = 1$$
    The subsequence ending at index 1 is simply the single-element sequence $\{a_1\}$, which has a length of 1.

    \item \textbf{Recursive definition of answers (with justification)}
    
    For $i > 1$:
    $$L[i] = 1 + \max\left(\{L[j] \mid 1 \le j < i \text{ AND } |a_i - a_j| \le K \text{ AND } L[j] > 0\} \cup \{0\}\right)$$
    
    \textit{Justification:}
    To find the longest valid subsequence ending at $a_i$, we iterate through all previous indices $j < i$. We check two conditions:
    \begin{enumerate}
        \item $L[j] > 0$ (this ensures the sequence ending at $j$ traces back to index 1).
        \item $|a_i - a_j| \le K$.
    \end{enumerate}
    If these conditions are met, we can extend the sequence from $j$ by appending $a_i$. If no such $j$ exists, $L[i]$ remains 0, indicating the chain is broken. We take the maximum to ensure optimality.

    \item \textbf{Order in which sub-problems are solved}
    
    We solve for $L[i]$ in increasing order of $i$, from $i = 2$ to $n$. This ensures that when computing $L[i]$, the values for all potential predecessors $L[1], \dots, L[i-1]$ are already available.

    \item \textbf{Form of output}
    
    The final answer is the maximum value in the array $L$:
    $$\text{Result} = \max_{1 \le i \le n} (L[i])$$

    \item \textbf{Pseudocode}
    
    \begin{algorithmic}[1]
    \Function{LongestBoundedSubsequence}{$A, n, K$}
        \State Let $L$ be an array of size $n+1$ initialized to $0$
        \State $L[1] \gets 1$
        \State $max\_length \gets 1$
        
        \For{$i \gets 2$ to $n$}
            \For{$j \gets 1$ to $i-1$}
                \State $diff \gets |A[i] - A[j]|$
                \If{$L[j] > 0$ \textbf{and} $diff \le K$}
                    \State $L[i] \gets \max(L[i], L[j] + 1)$
                \EndIf
            \EndFor
            \If{$L[i] > max\_length$}
                \State $max\_length \gets L[i]$
            \EndIf
        \EndFor
        
        \State \Return $max\_length$
    \EndFunction
    \end{algorithmic}

    \item \textbf{Runtime analysis}
    
    \begin{itemize}
        \item Time complexity: $O(n^2)$. The algorithm uses two nested loops. The outer loop runs $n$ times, and the inner loop runs $i$ times. The total operations are proportional to $\sum_{i=1}^{n} i \approx \frac{n^2}{2}$.
        \item Space complexity: $O(n)$. We utilize a single array $L$ of size $n$ to store the sub-problem solutions.
    \end{itemize}

    \item \textbf{A small example explained}
    
    Input: $A = [2, 7, 1, 4, 3]$, $K = 2$.
    Initialize $L = [0, 0, 0, 0, 0]$.
    
    \begin{itemize}
        \item $i=1$: Base case $L[1] = 1$. $L=[1, 0, 0, 0, 0]$.
        \item $i=2$ ($val=7$): Compare with $j=1$ ($val=2$). $|7-2|=5 > K$. No update. $L[2]=0$.
        \item $i=3$ ($val=1$): Compare with $j=1$. $|1-2|=1 \le K$. Update $L[3] = 1+1=2$. $L=[1, 0, 2, 0, 0]$.
        \item $i=4$ ($val=4$): 
        \begin{itemize}
            \item Compare $j=1$: $|4-2|=2 \le K \to L[4]=2$.
            \item Compare $j=3$: $|4-1|=3 > K \to$ No update.
        \end{itemize}
        $L=[1, 0, 2, 2, 0]$.
        \item $i=5$ ($val=3$):
        \begin{itemize}
            \item Compare $j=1$: $|3-2|=1 \le K \to L[5]=2$.
            \item Compare $j=3$: $|3-1|=2 \le K \to L[5]=\max(2, L[3]+1) = 3$.
            \item Compare $j=4$: $|3-4|=1 \le K \to L[5]=\max(3, L[4]+1) = 3$.
        \end{itemize}
        Final $L=[1, 0, 2, 2, 3]$.
    \end{itemize}
    
    \textbf{Result:} The maximum value in $L$ is \textbf{3}.

% MARK: Question 3
\newpage
\item \textbf{Minimum weight connected subtree of given size}

You are given a binary tree of size $n$, where every vertex $x$ has pointers $lc.x$, and  $rc.x$ (which could be NIL if those children don't exist) and each vertex has a value, $value.x > 0$. You are also given an integer $1 \le k \le n$.  You want to find the connected sub-tree with exactly $k$ vertices, which minimizes the total weight of vertices in the sub-tree. 

\begin{enumerate}
    % MARK: Q3.a
    \item Characterize Sub Problems
    
    Find the size and weight of every subtree within the initial tree. If the tree has k nodes, compare the weight of that tree to the running minimum. 

    The set of all distinct subproblems, $S$, = the subtrees starting at every distinct node $v \in V$. This implies there are $|S| = |V| = n$ distinct subproblems

    % MARK: Q3.b
    \-\
    \item Base Case
    
    The root of the subtree has no children (the subtree is 1 node). 
    \begin{itemize}
        \item $size = 1$
        \item $weight = value.v$
    \end{itemize}

    % MARK: Q3.c
    \-\
    \item Recursive Definition of Answers
    
    If $|v.children| = 0:$
    \begin{eqnarray*}
        weight[v] &=& value.v \\
        size[v] &=& 1
    \end{eqnarray*}

    If $|v.children| = 1:$
    \begin{eqnarray*}
        weight[v] &=& value.v + weight[v.child] \\
        size[v] &=& 1 + size[v.child]
    \end{eqnarray*}

    else:
    \begin{eqnarray*}
        weight[v] &=& value.v + weight[lc.v] + weight[rc.v] \\
        size[v] &=& 1 + size[lc.v] + size[rc.v]
    \end{eqnarray*}

    Brief Justification: For each subtree subproblem, there are 3 possibilities:
    \begin{itemize}
        \item The root of the subtree has no children. In this case the size of the subtree is just 1, and its weight is just the weight of its root. There is no recursive relationship, and thus the return values do not depend on the memoized array.
        
        \-\
        \item The root of the subtree has 1 child. In this case the size of the subtree is 1 + the size of the root's only child, and the weight it the weight of root + the weight of its child. In this case, the current solution depends on the return values of its only child, thus the call to $weight[v.child]$ and $size[v.child]$
        
        \-\
        \item The root of the subtree has 2 children. In this case the size of the subtree is 1 + the size of each of the subtrees rooted at its children, and its weight is the weight of the root + the weight of those subtreets. The solution depends on the return values of both the left and right child. 
    \end{itemize}

    Therefore, the above recurrence covers the only 3 possibly cases for each subtree in the graph. 

    % MARK: Q3.d
    \-\
    \item Subproblem Order
    
    The subproblem originating at node $v$ must come after the subproblems originating at its children. Therefore, subproblems must be solved in a post-order traversal (both children before their parents. )

    % MARK: Q3.e
    \-\
    \item Form of Output
    
    While calculating the weight of each subtree, keep track of the smallest weight. For those with node count = $k$, check if its weight it lower than the current smallest. After scanning through all subtrees, return the smallest. 


    \emph{Note: Alternatively, keep track of node v where the smallest subtree occurs to return not just the smallest weight, but the root of the subtree too.}

    % MARK: Q3.f
    \-\
    \item Pseudocode
    
    \begin{lstlisting}
    def MWCS(root, k) -> smallest:

    // if a subtree does not contain k nodes (ie. does not satisfy constraints of potential solution)
    // return infinity
    smallest = infinity

    for v in (post-order traverse root):
        if |v.children| == 0:
            weight[v] = v.value
            size[v] = 1
        
        if |v.children| == 1:
            weight[v] = v.value + weight[v.child]
            size[v] = 1 + size[v.child]

        else:
            weight[v] = v.value + weight[lc.v] + weight[rc.v]
            size[v] = 1 + size[lc.v] + size[rc.v]
        
        // attempt to update the variable for subtrees satisfying problem constraints
        if size[v] == k:
            smallest = min(smallest, weight[v])
    
    return smallest
    \end{lstlisting}

    % MARK: Q3.g
    \-\ 
    \item Runtime Analysis
    
    \begin{itemize}
        \item Post-traversal $\in O(n)$
        \item Runtime for each node: $\in O(1)$
    \end{itemize}

    Thus, total runtime $\in O(n)$

    % MARK: Q3.h
    \-\
    \item Small Example

    \includegraphics[width=0.7\textwidth]{src/Q3J.jpg}

\end{enumerate}


% MARK: Question 4
\newpage
\item \textbf{Road trip}

You are going on a long trip. You start on the road at mile post 0. Along the way there are $n$ hotels, at mile posts $a_1 < a_2 < \cdots < a_n$, where each $a_i$ is measured from the starting point. The only places you are allowed to stop are at these hotels, but you can choose which of the hotels you stop at. You must stop at the final hotel (at distance $a_n$), which is your destination.

You'd ideally like to travel 200 miles a day, but this may not be possible (depending on the spacing of the hotels). If you travel $x$ miles during a day, the {\it penalty} for that day is $(200 - x)^2$. You want to plan your trip so as to minimize the total penalty---that is, the sum, over all travel days, of the daily penalties.


% MARK: Question 5
\newpage
\item \textbf{Knapsack variant}

Consider the variant of knapsack where you are allowed to choose items more than once. You still have $n$ items each with values $v_i$ and costs $c_i$, and a budget $U$.  If you pick item $i$ $p_i$ times, you must have $\sum_{1 \le i \le n} p_i c_i \le U$, and your objective is to maximize $\sum_{1 \le i \le n} p_i v_i$.  Each $p_i$ must be a non-negative integer.

\end{enumerate}
\end{document}

