\documentclass[12pt, letterpaper]{article}

\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage[left=0.6in, right=0.6in, top=1in, bottom=1in]{geometry}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
% \usepackage{changepage}
\usepackage{xcolor}
\usepackage{amsmath}

% for code snippets
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0.5,0.65,0.5}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{code_blue}{rgb}{0.10,0.27,0.92}
\definecolor{str_red}{rgb}{0.87,0.2,0.14}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{code_blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{str_red},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{CSE 101 Homework 4}
\author{Kreshiv Chawla, Brian Masse, Taira Sakamoto, Emily Xie, Annabelle Coles}
\date{October 31, 2025}

\begin{document}

\maketitle
\newpage

\begin{enumerate}

% MARK: Question 1
\item \textbf{Maximum consecutive sum}

Here is an algorithm that, given an array
of integers (not necessarily positive) $A[1..n]$,
finds the maximum sum of a consecutive
subarray, $\max_{1 \le I \le J \le n} \sum_{K=I}^{J} A[K]$.
\par
\begin{enumerate}
\item Initialize $MaxSumEndingAt[1..n]$.
\item $MaxSumEndingAt[1]=A[1]$
\item For $J=2$ to $n$ do:
\item \hspace{1em}$MaxSumEndingAt[J] = \max(A[J],\, A[J]+MaxSumEndingAt[J-1])$
\item $MaxConsSum= MaxSumEndingAt[1]$.
\item For $J=2$ to $n$ do:
\item \hspace{1em}$MaxConsSum= \max(MaxConsSum,\, MaxSumEndingAt[J])$
\item Return $MaxConsSum$
\end{enumerate}

% ==== Replaced Parts Aâ€“D with your text ====
\begin{enumerate}
        \item For each $J \in \{1, \dots, n\}$,
        \[
        \text{MaxSumEndingAt}[J] = \max_{1 \leq i \leq J} \sum_{k=i}^{J} A[k]
        \]
        This means it stores the largest sum of any non-empty subarray that ends at position $J$.  
        From the algorithm, this can also be written as:
        \[
        \text{MaxSumEndingAt}[J] = \max(A[J],\, A[J] + \text{MaxSumEndingAt}[J-1]).
        \]
        
        \item \textbf{Loop invariant:} Before each loop iteration at index $J$ ($J \ge 2$), $\text{MaxSumEndingAt}[t]$ holds the correct value for all $t \in \{1, \dots, J-1\}$.  
        After computing line 4 for $J$, the invariant also holds for index $J$.
        
        \textbf{Proof:}
        \begin{itemize}
            \item \textit{Base case ($J=2$):} This is the state before the first loop iteration. Line 2 sets $\text{MaxSumEndingAt}[1] = A[1] = \max_{1 \le i \le 1} \sum_{k=i}^{1} A[k]$.
            \item \textit{Inductive step:} Assume the invariant holds up to $J-1$. The best subarray ending at $J$ either:
            \begin{enumerate}
                \item starts fresh at $A[J]$, or
                \item continues from the best subarray ending at $J-1$.
            \end{enumerate}
            Therefore,
            \[
            \text{MaxSumEndingAt}[J] = \max(A[J],\, A[J] + \text{MaxSumEndingAt}[J-1]),
            \]
            which matches the formula, so the invariant holds for $J$.
        \end{itemize}

        \item The goal is to find:
        \[
        \text{Ans} = \max_{1 \le I \le J \le n} \sum_{k=I}^{J} A[k].
        \]
        Since each $\text{MaxSumEndingAt}[J]$ gives the best sum ending at $J$,
        \[
        \text{Ans} = \max_{1 \le J \le n} \text{MaxSumEndingAt}[J].
        \]
        The second loop keeps track of this maximum:
        \[
        \text{MaxConsSum} = \max(\text{MaxConsSum},\, \text{MaxSumEndingAt}[J]).
        \]
        Initially (line 5), $\text{MaxConsSum} = \text{MaxSumEndingAt}[1]$.  
        At the end (line 8), $J=n$ so $\text{MaxConsSum} = \max_{1 \le J \le n}\text{MaxSumEndingAt}[J]=\text{Ans}$.

        Hence, the algorithm is correct.

        \item The first loop (lines 3--4) runs $n-1$ times, each taking constant time.  
        The second loop (lines 6--7) also runs $n-1$ times.  
        Therefore, the total time is $\Theta(n)$.
\end{enumerate}


% MARK: Question 2
\newpage
\item \textbf{Maximum within sliding window}

You are given an array $A[1..n]$ of integers, and an integer $1 \le k \le n$.
You wish to compute $MaxInWindow[I]= max_{I \le J \le min(I+k,n)} A[J]$ for all $1 \le I \le n$.  
By answering the questions below, you'll develop an efficient algorithm for this problem. 
A helpful abstraction will be to consider a window set at each $I$,
$WS[I] = \{(J, A[J]) | I \le J \le min(I+k,n)\}$.  
\begin{description}
\item In terms of the window set at $I$, what is $MaxInWindow[I]$?  
(2 points)
\item What is the difference between $WS[I]$ and $WS[I+1]$?   
(3 points)

The window set $WS[I+1]$ differs from $WS[I]$ by one element leaving and one new element entering the window. Specifically, $(I, A[I])$ is removed from the set and $(I+k+1, A[I+k+1])$ is added, given that ($I+k+1 \leq n$).

\item Based on your answers to the first two questions, what data structure operations would we want a data structure for $WS$ to support?
(3 points)

We need the following data structure operations:
\begin{itemize}
  \item insert(x) - In order to add the new element entering the window
  \item delete(x) - In order to delete the element exiting the window
  \item get_max() - To get the current maximum value within the window
\end{itemize}

\item What data structure could we use for $WS$?  
(3 points)

Data structures that support the needed operations lisited above includes both Balanced Binary Search Tree (BST) and Double Ended Queue.

\item What is the maximum size of this data structure?  (2 points)

The maximum size of this data structure is k elements because the window covers k indices.

\item How long do the different data structure operations take? (3 points)

The data structure operations takes:
\begin{itemize}
\item insert: O(log k)
\item delete: O(log k)
\item get_max: O(log k)
\end{itemize}

\item Give pseudo-code for an algorithm to solve this problem using data structure operations. (5 points)  
\item Give a time analysis for your algorithm, using answers to previous questions.(4 points). 
\end{description}



% MARK: Question 3
\newpage
\item \textbf{Subway stops}

Underneath a city road, there are $n$ subway stops 
$s_1,...s_n$ and
$k$ subway lines.  Each subway line $k$ stops at some of the stops, in the
same order, with line $k$ stopping at $s_{i_{k,1}},...s_{i_{k, t_k}}$,
where $i_{k,1} < i_{k,2}... < i_{k,t_k}$.  You want to go from $s_1$
to $s_n$ making as few transfers between lines as possible.       

For example, there might be five stops, and three lines.
The first line might stop at stops $1,3$, the second at $2,4, 5$, and the
third at $2,3,4$.    Then we could board on line 1, take it to stop $3$,
switch to line 3, take it to stop 4, switch to line 2 and take it to the end.

Below, you will describe how to use a graph algorithm from class to solve the
problem.
\begin{enumerate}

% PART A
\item  What graph will you use to solve the problem?  Be sure to specify the set of vertices in your graph, the set of edges, whether the edges are directed or undirected, and what weights edges have, if any.  

\begin{itemize}
    \item This will be a directed graph. Each node \(S_{i,k}\) represents a subway station \(i\) reached by subway line \(k\)
    \item There will be unweighted (weight = 0), directed edges representing getting from one subway station to another via line \(k\)
    \item There will be weighted (weight = 1), undirected edges representing switching subway line at a single station. For example, these edges will go from vertex \(S_{i, k_1}\) to \(S_{i, k_2}\)
\end{itemize}

% PART B
\item How will you create the graph from the information given?  What format will you use for the graph?  How long does it take to create the graph?

To create the graph from the given information:
\begin{itemize}
    \item Create a grid of k rows by n columns of verticies. Label each \(S_{row, col}\)
    \item Draw unweighted, directed edges from \(S_{i_1, k}\) to \(S_{i_2, k}\) (collection of all stations reachable by line k) for every rail line k. 
    \item Draw weighted (weight = 1), undirected edges between the rail stops at each specific station
    \item Create a single node at the start and end of the graph, with directed, unweighted edges to all \((S_i,k)\) stops. This will serve as the start and end goals of the algorithm.
    \item Remove any unused rail stops. (a rail line that is not used at station \(i\)
\end{itemize}

Given the answers in the following 2 questions, you must draw at most \(n \cdot k\) + 2 nodes, \((n-1) \cdot k\) rail connections, 2\(\cdot (k-1) \cdot n\) rail line changes, and \(2k\) edges from the first/last nodes to the first/last stations. Asymptotically, it will take \(O(nk)\)
\-\ \newline

% PART C
\item How many vertices does your graph have, at most? Give this in terms of $n$ and $k$.
\[ |V| \le n\cdot k + 2\]

\item How many edges does your graph have, at most? Give this in terms of $n$ and $k$ 

\begin{itemize}
    \item Directed Edges. If each rail line connects to every stations, there are at most \((n-1) \cdot k \) edges
    \item Undirected Edges. To connect every rail line at every station requires 2 directed edges, so there are at most \( 2(k-1) \cdot n \) edges
    \item Extra Edges. If there are k rail line connections at the first and last stations, then the first and last nodes will have \(k\) edges to and from them respectively. 
\end{itemize}

\[ |E| \le (n-1)\cdot k + 2(k-1)\cdot n + 2\cdot k\]

% PART D
\item  How do paths in your graph relate to ways of transfering? What is the relationship between the length of paths and the number of transfers? 

Unweighted edges represent no transfers. Subway line transfers have a weight of 1. Thus the weigh of the paths from \(S_1\) to \(S_n\) is the number of transfers made during that trip.
\-\ \newline

% PART E
\item What algorithm from class will you run on the graph?
Be sure to specify all inputs to this algorithm, and say how you use the results.

\-\ \newline
The modified Dijkstras algorithm should be used to find the shortest weighted path between the first and last subway station. This will automatically minimize the number of transfers. 

\-\ \newline
The algorithm would assume the goal is to get from station \(S_1\) to station \(S_n\). It would run the modified Dijkstras algorithm from class on the first node and try to reach the last node.

\-\ \newline
The fully weighted and directed graph would be input (either in adjacency  list or matrix format). The result would either be the length of the shortest trip, or an array of previous nodes showing the shortest path.

% PART F
\-\ \newline
\item What is the total time complexity of using this algorithm from class to solve the subway transfer problem?  This should be given in terms of $n$ and $k$.

The algorithm uses the same Dijkstras algorithm we used in class, and has the same time complexity: \( O( |RemoveMin||V| + |ReduceKey||E| ) \)

For this problem specifically:
\begin{eqnarray*}
    && O(|RemoveMin| \cdot (nk) + |ReduceKey| \cdot (nk) )\\
    &\in& O( (nk) \cdot ( |RemoveMin| + |ReduceKey|) )
\end{eqnarray*}

Depending on the underlying implementation of the min-heap, the exact time complexity would vary. 

\end{enumerate}



% MARK: Question 4
\newpage
\item \textbf{Vertex costs}

Say we are given a graph $G$ where both vertices and edges
have positive integer weights and two vertices $u$, $v$.  
We want to find a path from $u$ to $v$ 
that minimizes the total weights of both edges and vertices along the path.
Give an efficient algorithm to solve this problem.  You can use any algorithm
from class as given, but need to relate the correctness guarantee proved for
that algorithm to correctness for this new problem.
(10 points clear algorithm description, 10 points correctness argument, 5 points time analysis and efficiency)

\end{enumerate}
\end{document}

