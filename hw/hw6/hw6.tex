\documentclass[12pt, letterpaper]{article}

\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage[left=0.6in, right=0.6in, top=1in, bottom=1in]{geometry}

% for code snippets
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0.5,0.65,0.5}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{code_blue}{rgb}{0.10,0.27,0.92}
\definecolor{str_red}{rgb}{0.87,0.2,0.14}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{code_blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{str_red},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{CSE 101 Homework 6}
\author{Brian Masse, Kreshiv Chawla, Taira Sakamoto, Emily Xie, Annabelle Coles}
\date{November 25, 2025}

\begin{document}

\maketitle
\newpage

\begin{enumerate}

% MARK: Question 1
\newpage
\item \textbf{Recurrence Relations}

\begin{enumerate}
\item $T(n) = 4T(\lfloor n/4 \rfloor) + cn^3, n \ge 2,    T(1) = c$
\item $T(n) = 2*T(n-3 )$ for $n \ge 4$, $T(1)=c$
\item $T(n) =  T(\lfloor n/4 \rfloor) + c,  T(1) = c$
\item $T(n) = (\log n) T(\lfloor n/2 \rfloor ), n \ge 2; T(1)=c$.
\end{enumerate}

% MARK: Question 2
\newpage
\item \textbf{High Frequency Element}


Say we have an array of numbers $A[1...n]$.  $x$ is {\em high frequency } in $A$ if it occurs more than $ n/2 $ times in $A$, i.e., there are strictly more than $n/2$ many indices $1 \le i \le n$ with $A[i]=x$.  Here's an algorithm that finds a high frequency element if one exists (it may return an element if no high frequency element exists):

\par
HF(A[1..n])
\begin{enumerate}
\item If $n=0$ return ``No HF element''. 
\item If $n=1$ return $A[1]$.
\item If $n$ is odd do:
\item ~~~~$Count=0$
\item ~~~~FOR $I=1$ to $n$ IF $A[I]=A[n]$ THEN $Count++$
\item ~~~~IF $Count > n/2$ THEN Return $A[n]$
\item Initialize an array $B[1.. \lfloor n/2 \rfloor]$.
\item $I=1, J=1$.
\item While $I < n$ do: 
\item ~~~IF $A[I]==A[I+1]$ THEN $B[J]=A[I], J++$
\item ~~~$I=I+2$.
\item Return $HF(B[1..J-1])$.
\end{enumerate}

Questions:
\begin{enumerate}
\item Give the recursive calls the algorithm would make on input
$A[1..7] = (1,4, 3,3, 2,3, 3)$.
\item Prove that if $x$ is a high-frequency element in $A[1..n]$, then
$x$ is a high frequency element in $B[1...J-1]$ at the end of the loop.
(Hint: look at the number of times each of the following occur for consecutive eelements of $A$: Both are $x$, both are some $y \neq x$, exactly one is $x$, neither is $x$ and are not equal.) 
\item Use this to prove that if $x$ is a high-frequency element in $A[1..n]$,
then $HF(A[1..n])=x$.
\item Give a worst-case time analysis for this algorithm.
\end{enumerate}

% MARK: Question 3
\newpage
\item \textbf{Weighted Median}


Say that we are given a list of pairs of values and weights, with weights greater than $0$, $(v_1,w_1),..(v_n,w_n)$.
Let $W= \sum_{1 \le i \le n} w_i$ be the total weight. The weighted median is a value $v_j$ with $\sum_{1 \le i \le n, v_i < v_j} w_i \le W/2$ and  $\sum_{1 \le i \le n, v_i > v_j} w_i \le W/2$.


For example, if the list had elements $(2,.1), (4,.2), (-3, .2),(1,.4), (5,.1)$,we can compute $W=1$, so $W/2=.5$.  A weighted median is $1$, because the sum of the weights of values less than $1$ is $.2$ and the sum of the weights larger than $1$ is $.1+.2+.1= .4$.

Give an efficient algorithm (faster than sorting the list) to compute a weighted
median. 

\-\ \newline 
\begin{lstlisting}
// pass in the list of pairs, the size of the list, and half the total weight
// The final piece can be precomputed in linear time. 
weighted_median(list L, size n, WM):

    // Find the median of the given list (by value, not weight)
    // Using the select algorithm from class
    median = select_lowest(L, n / 2)

    // create 3 sub array for pairs with a value <, =, > the median
    // keep track of their cumulative weight
    SL = []; WL = 0;
    SM = []
    SR = []; WR = 0;

    // loop through the list to build sub arrays.
    for pair in L:
        if pair.value < median.value:
            SL.add(pair)
            WL += pair.weight
        elif pair.value > median.value:
            SR.add(pair)
            WR += pair.weight
        else:
            SM.add(pair)

    // if both sides are less than the target weight, that value is the weighted median
    if (WL < WM && WR < WM):
        return median

    // run the algorithm recursively on whichever subset was greater than the target weight
    if (WL > WM):
        return weighted_median(WL, WL.size(), WM)
    else:
        return weighted_median(WR, WR.size(), WM)
\end{lstlisting}


\emph{Short Correctness Proof}

The algorithm recursively calls the select median algorithm discussed in class. It is assumed that, for any set, it correctly returns the median. Once the median is found, the algorithm uses it as a pivot to create 3 partitions: values less than the median, equal to the median, and greater than the median, and calculates the total weight of each partition. 

There are 2 outcomes:

\begin{itemize}
    \item  The weight of both subsets are less than $W/2$. This implies the median is the weighted median and returns
    \item The weight of one of the subsets is greater than $W/2$. In this case, the weighted median must be in the heavier subset, since being in either other subset implies values above or below it sum above $W/2$, violating the definition of the weighted median. Thus, the algorithm runs itself on the smaller subset. 
    
    \-\ \newline
    \emph{Note: Only 1 subset can have a weight $> W/2$, since all others must have weight $w < W/2$ to all sum to $W$}

    \emph{Note: A recursive call will never contain an empty set. If there are no numbers above or below the median returned by select, that number is the weighted median.}
\end{itemize}

\emph {Analysis / Efficiency}

This algorithm can be determined using the master theorem. First note:

\begin{itemize}
    \item Calculating target weight $\in O(n)$
    \item Select (from class) $\in O(n \cdot log(n))$
    \item partitioning into subsets $\in O(n)$
    \item The partitions will always be roughly $n/2$ elements large, since they use the median as the pivot, which by definition is in the center of the set.
\end{itemize}

Together this implies the total time complexity, $T(n):$
\[ T(n) = 1 \cdot T( n / 2) + O(n \cdot log(n)) \]

\begin{enumerate}
    \item Only 1 subset is recursively called on $\implies$ 1 subroutine
    \item With median as input, subroutines are roughly $n / 2$
    \item The total time complexity of each call is dominated by the select median $\implies \in O(n \cdot logn)$
\end{enumerate}

By the master theorem:

\begin{eqnarray*}
    f(n) &=& n \cdot log(n) \\
    &\in& \Omega(n^{log_b(a)}) = \Omega(1) \\
    &\implies& T(n) \in O(f(n))
\end{eqnarray*}

Thus, the total runtime complexity is $O(n\cdot logn)$




% MARK: Question 4
\newpage
\item \textbf{Weighted Independent Set for Trees}

A subset $S$ of vertices in an undirected graph is an {\em independent
set} if it doesn't contain both ends of any edge.  If we assign every vertex a weight $w(x) >0$ , the {\em maximum weight independent set} is to find the independent set of the graph that has maximum possible
total weight of its vertices.  While the maximum weight independent set problem is $NP$-hard, some special cases can be solved efficiently. In particular, consider the special case when the underlying graph is a complete binary tree of depth $k$, so $|V|=2^{k+1}-1$.  Give a divide-and-conquer algorithm for
this problem that runs in polynomial time. (Hint: have your algorithm return not just the weight of the maximum weighted independent set, but both of the values for the two cases, the root is in $S$ and the root is not in $S$.  This problem can be solved using dynamic programming, but it is not required and the dynamic programming solution will not be given any credit for this assignment.) (5 points clear algorithm description, 5 points for short correctness argument, 5 points for correct time analysis, and 5 points for efficiency; the best algorithm is $O(|V|)$ time.)

% MARK: Question 5
\newpage
\item \textbf{Karatsuba implementation}

This problem is designed to teach you an idea that makes divide-and-conquer algorithms that only improve time for huge inputs into ones that give substantial improvements even for moderate sized inputs.

Implement both the Karatsuba method for multiplying polynomials from the ungraded problems above and
a straight-forward $O(n^2)$ polynomial multiplication algorithm.  Collect
average running times for a wide range of input sizes $n$, say powers of $2$ until the algorithm is
taking over 15 minutes to run,  for random polynomials with co-efficients
$0$ or $1$.   Graph these on a log-log scale, log n vs. log (algorithm time).  
How big are inputs where the Karatsuba method is faster, or how big would
you interpolate such inputs to be from your data (if there are no actual
data points where Karatsuba is better)?   Then try a hybrid algorithm,
where we use the Karatusba recursion when $n > T$ and the quadratic time
method in recursive calls when $n \leq T$.  For a wide range of possible
$T$'s, starting with rather small values such as $T=16$, graph the hybrid's
performance and compare to the other two.  What do you conclude from this
experiment?  

(2 points clearly describing features of implementation and experiment, 
such as PL, libraries, type of computer, etc.  For each of Karatsuba,
quadratic algorithm and hybrid, 2 points for running experiment with
adequate variety of input sizes and 2 points
for clearly presenting results. 6 points for conclusions 
based on comparing results.)




\end{enumerate}
\end{document}

