\documentclass[12pt, letterpaper]{article}

\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage[left=0.6in, right=0.6in, top=1in, bottom=1in]{geometry}

% for code snippets
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}

% for math and pseudocode
\usepackage{amsmath, amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}

\definecolor{dkgreen}{rgb}{0.5,0.65,0.5}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{code_blue}{rgb}{0.10,0.27,0.92}
\definecolor{str_red}{rgb}{0.87,0.2,0.14}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{code_blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{str_red},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{CSE 101 Homework 8}
\author{Brian Masse, Taira Sakamoto, Emily Xie, Annabelle Coles}
\date{December 5, 2025}

\begin{document}

\maketitle
\newpage

\begin{enumerate}

% MARK: Question 1
\newpage
\item \textbf{Verifying Heap}

A \emph{3-ary heap} is like a binary heap, except that every internal vertex has three children: \emph{left}, \emph{middle} and \emph{right}. We will use $v.\mbox{left}$, $v.\mbox{mid}$, and $v.\mbox{right}$ to denote the three children. We let $v.\mbox{value}$ denote the value stored at $v$. We consider only the case of complete trees,  so all three sub-trees rooted at the three children will have the same size.  

Here's an algorithm that verifies whether a balanced complete $3$-ary tree
has the min-heap property.

{\bf IsHeap}($r$ : root of 3-ary heap $H$)
\begin{itemize}
\item IF $r$ is a leaf: return {\tt true} 
\item IF $r.\mbox{value} > r.\mbox{left}.\mbox{value}$ return {\tt false}
\item IF $r.\mbox{value} > r.\mbox{mid}.\mbox{value}$ return {\tt false}
\item IF $r.\mbox{value} > r.\mbox{right}.\mbox{value}$ return {\tt false}
\item IF $\mbox{IsHeap}[r.\mbox{left}]==\mbox{\tt false}$ return {\tt false}
\item IF $\mbox{IsHeap}[r.\mbox{mid}]==\mbox{\tt false}$ return {\tt false}
\item IF $\mbox{IsHeap}[r.\mbox{right}]==\mbox{\tt false}$ return {\tt false}
\item Return {\tt true}
\end{itemize}


\begin{enumerate}
\item[(a)] Give a recurrence for the time taken by IsHeap in 
terms of the total size, $n$, of the heap rooted at $r$.  Explain your answer.

The recurrence is: 
\[ T(n) = 3T(n/3) + O(1) \]

The algorithm performs a constant amount of work at the current node (checking if it is a leaf and performing 3 comparisons of values). It then makes recursive calls on the three children. Since the tree is a complete 3-ary tree, the problem size $n$ is split evenly among the three subtrees. Therefore, there are 3 recursive calls, each on an input of size approximately $n/3$.

\item[(b)] Give a time analysis for IsHeap by solving this 
recurrence, up to order.  If you use the Master Theorem, be sure to give the
values of the three parameters used, and the case it falls under.

Use the Master Theorem of the form $T(n) = aT(n/b) + f(n)$.

The parameters are:
\begin{itemize}
    \item $a = 3$ (number of recursive subproblems)
    \item $b = 3$ (factor by which the input size is reduced)
    \item $f(n) = O(1)$ (cost of work outside the recursive calls)
\end{itemize}

Compare $f(n)$ to $n^{\log_b a}$:
\[ \log_b a = \log_3 3 = 1 \]
Therefore, comparing $f(n) = 1$ to $n^1$.

Since $f(n) = O(n^{1 - \epsilon})$ (for any $0 < \epsilon \le 1$), this falls under case 1 of the Master Theorem.

The complexity is:
\[ T(n) = \Theta(n^{\log_b a}) = \Theta(n) \]
\end{enumerate}

% MARK: Question 2
\newpage
\item \textbf{Median of Sorted Lists}

The following algorithm finds the median ($n$th smallest element) of two sorted lists of distinct integers, $A[1..n]$ and $B[1..n]$. For simplicity, we assume $n=2^k$ is a power of $2$.

MedianSorted(A[1..n],B[1..n])
\begin{enumerate}
\item IF $n=1$ THEN Return $\min(A[1], B[1])$.
\item IF $A[n/2] < B[n/2+1]$
\item ~~~~~ THEN Return $\text{MedianSorted}(A[n/2+1..n], B[1..n/2])$.
\item IF $A[n/2] > B[n/2+1]$
\item ~~~~~ THEN Return $\text{MedianSorted}(A[1..n/2], B[n/2+1..n])$.
\item IF $A[n/2] = B[n/2+1]$
\item ~~~~~ THEN Return $A[n/2]$.
\end{enumerate}

\begin{enumerate}
\item[(a)] \textbf{Recurrence for the worst--case time}

Let $T(n)$ denote the worst--case running time of \textsc{MedianSorted} on two sorted lists of length $n$.

In every call with $n > 1$, the algorithm performs a constant amount of work (comparisons and index checks), which takes $\Theta(1)$ time, and then makes \emph{exactly one} recursive call on two subarrays of size $n/2$ (line 3 or line 5).  

Thus, the recurrence is:
\[
T(n) = T\!\left(\frac{n}{2}\right) + \Theta(1), \qquad T(1)=\Theta(1).
\]

\item[(b)] \textbf{Solving the recurrence}

We apply the Master Theorem to the recurrence:
\[
T(n) = a\,T\!\left(\frac{n}{b}\right) + f(n),
\]
with parameters:
\[
a = 1,\qquad b = 2,\qquad f(n)=\Theta(1).
\]

Compute the critical exponent:
\[
n^{\log_b a} = n^{\log_2 1} = n^0 = 1 = \Theta(1).
\]

Since 
\[
f(n)=\Theta(1)=\Theta\!\left(n^{\log_b a}\right),
\]
this falls under \textbf{Case 2} of the Master Theorem.

Therefore,
\[
T(n) = \Theta\!\left(n^{\log_b a}\log n\right)
      = \Theta(1 \cdot \log n)
      = \Theta(\log n).
\]

Thus, \textsc{MedianSorted} runs in $\Theta(\log n)$ time.
\end{enumerate}
% MARK: Question 3
\newpage
\item \textbf{Taxi Stand}

At a taxi stand, there is a line of customers $C_1,..C_n$ and a line of taxis, $T_1,...T_m$. Since taxis are licensed to drive in some towns but not others, each can serve some of the customers but not others. We need to assign each customer to a taxi, and the assigned taxis need to be in order, but not all taxis need to be assigned. We want to minimize the position of the last taxi to be assigned.

For example, if we have three customers $A,B,C$ and four taxis, $1,2,3,4$ where $1$ can serve $A$ and $C$, 2 can serve $A$ and $C$, $3$ can serve $B$ and $C$, and $4$ can serve $B$ and $C$, we could assign $A$ to taxi $2$, $B$ to taxi $3$ and $C$ to taxi $4$.  

\begin{enumerate}
\item Fill out the rest of the problem specification with mathematical expressions clearly defining the constraints and objective:

\begin{itemize}
\item Instance: Bipartite graph $G$ whose left vertices represent customers and right vertices represent taxis, and an edge $(C,t)$ represents taxi $t$ being able to serve  customer $C$, with orderings $C_1...C_n$ and $t_1..t_m$ on the two sets of vertices, with $m >n$.

\item Solution Format: A list of taxis $i_1,i_2,..i_n$, with taxi $i_j$ assigned to customer $j$.

\item Constraints:  Each customer must be assigned to a taxi that can drive them to their destination, i.e, $\exists$ an edge $(j, i_j)$ for every $1 \le j \le n$.  And  each customer must be assigned to a later taxi than the previous customer, i.e., $i_j < i_{j+1}$
\item Objective: Minimize the position of the last taxi, $i_j$
\end{itemize}

\-\
\item Give a high level greedy strategy that solves this problem.

For custom $C_k$ choose the lowest taxi $T_j$ such that $\exists$ an edge $(C_k, T_j) \in G$ and the previously selected taxi, $i_{k-1} < T_j$. For the first customer, $C_1$, assign them the lowest taxi such that $(C_1, T_j)$ exists. 

\-\
\item Illustrate your strategy on the example given in the problem.

\begin{center}
\begin{tabular}{ |c|c|c|c| } 
 \hline
 k & $i_1$ & $i_2$ & $i_3$ \\
 \hline
 1 & 1 & - & - \\
 1 & 1 & 3 & - \\
 1 & 1 & 3 & 4 \\
 \hline
\end{tabular}
\end{center}

\item Prove your strategy finds the optimal solution, using any technique we've learned.  You can state and prove the main lemmas rather than give the complete proof, such as stating and proving a modify-the-solution lemma but skipping the induction argument. 

\end{enumerate}

% MARK: Question 4
\newpage
\item \textbf{Maximizing inner product}

Say we are given two sequences of integers $x_1,..x_n; y_1,..y_m$ with $m \ge n$.  We want to find a subsequence of $y_1,..y_m$ of length $n$ , $y_{i_1} , y_{i_2},..y_{i_n}$ with $1 \le i_1 < i_2 <...< i_n \le m$ that maximizes the {\em inner product} $\sum_{1 \le j \le n} x_j * y_{i_j}$.  

For example, if $x$ is $3,2,4$ and $y$ is $5,6, 1,2, 8$, the optimal subsequence
is $5,6,8$ giving objective $3*5+2*6+4*8= 59 $.  
   
Here's a recursive algorithm to find the maximum inner product with a subsequence:

MIPWS($x_1,..x_n; y_1,..y_m)$
\begin{itemize}
\item IF $n=0$ THEN return $0$
\item IF $n=m$ THEN return 
$x1*y_1 + MIPWS(x_2,..x_n;y_2..y_m)$ 
\item Return $max 
(x1*y_1 + MIPWS(x_2,..x_n;y_2..y_m), MIPWS(x_1..x_n;y_2...y_m)$. 
\end{itemize}

Questions

\begin{enumerate}
\item Show the tree of recursive calls this algorithm makes on the above example.   (You can either draw the tree, or list the recursive calls, using indentation to indicate nesting. You can use abbreviations like $2-4,2-5$ to mean calling the algorithm on $x_2..x_4; y_2..y_5$)

\includegraphics[scale=0.35]{src/Q4A-recursive-tree.png}

\-\
\item Give a recurrence for the total number of recursive calls this algorithm makes, in terms of $n'=n+m$.
\begin{itemize}
    \item $T(n) = T(n' -2 )+ T(n' -1) + O(1)$
\end{itemize}
\-\ \newline
In the rest of this part, you will give a dynamic programming algorithm
for this problem.  Your algorithm can be based on the above recursion, or
some other case analysis.

\-\
\item Describe precisely the sub-problems that your dynamic programming
algorithm solves.  
Define an array or matrix to hold these answers.

The three subproblems are the function calls in lines two and three: 
\begin{itemize}
    \item $MIPWS(x_2,..x_n;y_2..y_m)$
    \item $(x_1*y_1 + MIPWS(x_2,..x_n;y_2..y_m)$
    \item $MIPWS(x_1..x_n;y_2...y_m)$
\end{itemize}

We will use a 2D matrix called MIP to store the outputs of the subproblems. The matrix will have dimensions $(n+1,m+1)$.
\-\
\item Describe the base cases in terms of your array or matrix.
\begin{itemize}
    \item The base case is when $n==0$ when the x array is empty. This refers to the $n+1$ row in the DP output matrix.
\end{itemize}
\-\
\item Give a formula or pseudo-code saying how you compute
larger sub-problems in terms of smaller sub-problems.  
\begin{itemize}
    \item Add previous subproblem output to the multiplication of the current elements and compare to other subproblem outputs.
    \item Formula: $MIP[i+1][j+1] \leftarrow max(x[i]*y[j]+MIP[i][j], MIP[i][j+1], MIP[i+1][j]))$ 
\end{itemize}

\-\
\item Explain the case-analysis that justifies the previous step.
\begin{itemize}
    \item In the base case, when the array is empty we get zero, which is a given.
    \item By calculating the max of the subproblems, it is ensured that we find the maximum inner product.
    \item Since we loop through all of the x-array and the y-array, we check all possible dot products of the elements.
    \item Since we have already solved the subproblems for $i,j$ and we initialize the MIP matrix with zeros, we can always calculate $MIP[i+1][j+1]$. 
\end{itemize}
\-\
\item Assemble the parts above into a dynamic programming algorithm,
described in pseudocode. Be sure to specify the order in which sub-problems are solved, and what the final output is.
s
Replacing function calls with outputs from matrix:
\begin{itemize}
    \item $MIP \leftarrow [[0] * (nm1)] * (n +1)$
    \item FOR $i=1$ to $n$ do:
    \item ~~~FOR $j=1$ to $m$ do:
    \item ~~~~~~$MIP[i+1][j+1] \leftarrow max(x[i]*y[j]+MIP[i][j], MIP[i][j+1], MIP[i+1][j])$ 
    \item Return $MIP[n][m]$
\end{itemize}

We solve the subproblems in increasing order from $i=1$ to $i=n$. We fill the later $MIP[x_{i+1}][y_{j+1}]$ matrix entries using the outputs from the earlier subproblems where we found $MIP[x_i][y_j]$. The final output is the value stored at position $MIP[n][m]$, this is the maximum inner product. 
\-\
\item Give a time analysis for your dynamic programming algorithm
in terms of $n$. 
\begin{itemize}
    \item For each index in the DP output array we need to do one addition and comparison. There are two nested for loops that will take $O(n\cdot m)$. Given $m \ge n$, in the worst case $m==n$ so $O(n\cdot m)= O(n^2)$
\end{itemize}
\-\
\item Show the array or matrix your algorithm produces on the
example above.


\includegraphics[scale=0.45]{src/Q4I-output-MIP-matrix.png}
\end{enumerate}

\end{enumerate}
\end{document}
